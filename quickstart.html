<html>
<head>
    <script type="text/javascript">
        // Your Client ID can be retrieved from your project in the Google
        // Developer Console, https://console.developers.google.com
        var CLIENT_ID = '176049196616-koqftr6rrmlk91m5ssqdnbbe2cfdgsul.apps.googleusercontent.com';

        var SCOPES = ["https://www.googleapis.com/auth/calendar"];

        /**
         * Check if current user has authorized this application.
         */
        function checkAuth() {
            gapi.auth.authorize(
                    {
                        'client_id': CLIENT_ID,
                        'scope': SCOPES.join(' '),
                        'immediate': true
                    }, handleAuthResult);
        }

        /**
         * Handle response from authorization server.
         *
         * @param {Object} authResult Authorization result.
         */
        function handleAuthResult(authResult) {
            var authorizeDiv = document.getElementById('authorize-div');
            if (authResult && !authResult.error) {
                // Hide auth UI, then load client library.
                authorizeDiv.style.display = 'none';
                loadCalendarApi();
            } else {
                // Show auth UI, allowing the user to initiate authorization by
                // clicking authorize button.
                authorizeDiv.style.display = 'inline';
            }
        }

        /**
         * Initiate auth flow in response to user clicking authorize button.
         *
         * @param {Event} event Button click event.
         */
        function handleAuthClick(event) {
            gapi.auth.authorize(
                    {client_id: CLIENT_ID, scope: SCOPES, immediate: false},
                    handleAuthResult);
            return false;
        }

        /**
         * Load Google Calendar client library. List upcoming events
         * once client library is loaded.
         */
        function loadCalendarApi() {
            gapi.client.load('calendar', 'v3', doCalendarOperations);
        }

        /**
         *
         * Print the summary and start datetime/date of the next ten events in
         * the authorized user's calendar. If no events are found an
         * appropriate message is printed.
         */

        //TODO: handle these GLOBAL variable scope
        var ALLCALENDARS = {};

        function doCalendarOperations() {
            // make all calendar list
//            var request = gapi.client.calendar.calendarList.list();
//            request.execute(function (resp) {
//                var events = resp.items;
//                if (events.length > 0) {
//                    for (var i = 0; i < events.length; i++) {
//                        var event = events[i];
//                        ALLCALENDARS[event.id] = event.summary;
//                    }
//                } else {
//                    console.log('No calendar list found.');
//                }
//
//                //show calendar list
//                appendPre('<h2>List of Calendars</h2>');
//                for (var calId in ALLCALENDARS) {
//                    var summary = ALLCALENDARS[calId];
//                    appendPre('---' + summary + ' (' + calId + ')' + '<br><br>');
//                }
//
//            });

            /* ====== DATA FILTERING ============= */
            $(function () {

                $(document).ready(function () {
                    console.time('loaddata'); //TODO: remove

                    $.getJSON('dataset/FabianLocationHistory.json', function (data) {
                        filterDataset(data);
                    });
                });

                function filterDataset(data) {
                    console.timeEnd('loaddata'); //TODO: remove
                    console.time('filterDataset'); //TODO: remove

                    data = data.locations;

                    // TODO: testing template to be removed
                    (function testing() {
                    })();

                    // TODO: use actual testing
                    (function testing() {
                        if (data.length > 0) {
                            console.log("Data Load Test Passed!");
                            console.log("Number of rows:", data.length);
                        } else {
                            console.log("Data Load Test Failed!");
                        }
                    })();

                    // convert columns to expected format and add other new columns
                    data.forEach(function (row) {
                        var timestamp = parseInt(row.timestampMs),
                                rowDate = new Date(timestamp);

                        row.latitudeE7 = row.latitudeE7 / 10e6;
                        row.longitudeE7 = row.longitudeE7 / 10e6;
                        row.timestampMs = timestamp;

                        row.fullDate = rowDate;
                        row.day = rowDate.getDay();
                        row.date = extractDate(rowDate);
                        row.time = extractTime(rowDate);
                    });

                    // sorted entire time once otherwise have to sort each value from groupby date keys
                    var oldDataLen = data.length; //TODO: remove after passing test
                    data = _.sortBy(data, 'timestampMs');

                    // reduce data to only last N days
                    var noOfDays = 7;
                    var lastDay = data[data.length - 1],
                            lastDayTimestamp = lastDay.timestampMs,
                            dateOfLastDay = new Date(lastDayTimestamp),
                            nDaysAgoTimestamp = dateOfLastDay.setDate(dateOfLastDay.getDate() - noOfDays);

                    data = data.filter(function (row) {
                        return row.timestampMs >= nDaysAgoTimestamp &&
                                row.timestampMs <= lastDayTimestamp;
                    });

                    // TODO: use actual testing
                    (function testing() {
                        var newDataLen = data.length;
                        var diff = oldDataLen - newDataLen;
                        if (diff > 0) {
                            console.log("2 Weeks Test Passed!");
                            console.log("Number of rows dropped:", diff);
                        } else {
                            console.log("2 Weeks Test Failed!");
                            console.log("Old Length:", oldDataLen);
                            console.log("New Length:", newDataLen);
                        }
                    })();

                    /* ignore locations with accuracy over 1000m
                     * ignore all locations outside CITY
                     */
                    var CITY = [42.446594, -76.493736],
                            cityLatMargin = 0.1,
                            cityLonMargin = 1.0;

                    data = data.filter(function (row) {
                        return row.accuracy <= 1000 &&
                                Math.abs(row.latitudeE7 - CITY[0]) <= cityLatMargin &&
                                Math.abs(row.longitudeE7 - CITY[1]) <= cityLonMargin
                    });

                    // determine if location falls into specific location label such as home, work, etc
                    var HOME = [42.446594, -76.493736], // Fabian Home
                            WORK = [42.444877, -76.480814], //Gates Hall
                            HOBBY = [42.4333261, -76.4709491]; // woodcrest

                    var LAT_MARGIN = 0.00005,
                            LON_MARGIN = 0.0005;

                    data.forEach(function (row) {
                        if (Math.abs(row.latitudeE7 - HOME[0]) < LAT_MARGIN &&
                                Math.abs(row.longitudeE7 - HOME[1]) < LON_MARGIN) {
                            row.locationLabel = 'home';
                        } else if (Math.abs(row.latitudeE7 - WORK[0]) < LAT_MARGIN &&
                                Math.abs(row.longitudeE7 - WORK[1]) < LON_MARGIN) {
                            row.locationLabel = 'work';
                        } else if (Math.abs(row.latitudeE7 - HOBBY[0]) < LAT_MARGIN &&
                                Math.abs(row.longitudeE7 - HOBBY[1]) < LON_MARGIN) {
                            row.locationLabel = 'hobby';
                        }
                        else {
                            row.locationLabel = 'other';
                        }
                    });

                    /*
                     * add new calendar to calendar list
                     * avoid creating duplicate calendar
                     * store new calendar id in localStorage
                     */

                    if (localStorage.createdCalendarId === undefined) {
                        var createdCalendarSummary = 'My Location Calendar';
                        localStorage.createdCalendarSummary = createdCalendarSummary;
                        var request = gapi.client.calendar.calendars.insert({
                            'summary': createdCalendarSummary
                        });

                        request.execute(function (resp) {
                            console.log('Just added new calendar: ' + createdCalendarSummary);
                            localStorage.createdCalendarId = resp.result.id;
                            showClearThenBatchInsertEvents(localStorage.createdCalendarId, data);
                        });

                    }
                    else {
                        console.log("Created CalendarId already exists:", localStorage.createdCalendarId);
                        showClearThenBatchInsertEvents(localStorage.createdCalendarId, data);
                    }

                    function showClearThenBatchInsertEvents(calendarId, givenData) {

                        /*
                         * show all events
                         */
                        var request = gapi.client.calendar.events.list({
                            'calendarId': localStorage.createdCalendarId,
                            'showDeleted': false,
                            'singleEvents': true,
                            'orderBy': 'startTime'
                        });
                        request.execute(function (resp) {
                            var events = resp.result.items;
                            var text = "All Events Before Resetting " + localStorage.createdCalendarSummary;
                            appendPre('<h2>' + text + '</h2>');

                            if (events.length > 0) {
                                for (var i = 0; i < events.length; i++) {
                                    var event = events[i];
                                    var when = event.start.dateTime;
                                    if (!when) {
                                        when = event.start.date;
                                    }
                                    appendPre(event.summary + ' (' + when + ')' + '<br/>');
                                }
                            } else {
                                appendPre('No upcoming events found.');
                            }

                        });

                        /*
                         * remove events to avoid creating duplicates when refreshing page during testing phase
                         */
                        deleteAllEvents(calendarId).then(function (deleteResp) {
                            console.log("DeleteAllEvents response: ", deleteResp);

                            /*
                             * create new events where each event is time at each location of interest per day
                             * batch insert events to reduce HTTP overhead
                             * make sure calendar exists before you insert events
                             */
                            var dataForDay,
                                    allEventsForDay,
                                    request,
                                    groupedByDayData = _.groupBy(givenData, 'date');

                            var reverseAddressThenInsertRequest = function(ev) {
                                getReversedGeodata(ev.location).then(function (reversedAddress) {
                                    ev.location = reversedAddress;
                                    request = gapi.client.calendar.events.insert({
                                        'calendarId': localStorage.createdCalendarId,
                                        'resource': ev
                                    });
                                    request.execute();
                                });
                            }

                            for (var selectedDay in groupedByDayData) {

                                dataForDay = groupedByDayData[selectedDay];
                                allEventsForDay = getAllDwellTime(dataForDay);
                                console.log("No of events to be inserted:", allEventsForDay.length);

                                if (allEventsForDay.length > 0) {
                                    for (var i = 0; i < allEventsForDay.length; i++) {
                                        reverseAddressThenInsertRequest(allEventsForDay[i]);
                                    }
                                }
                            }

                        });
                    }

                    console.timeEnd('filterDataset');
                    console.time('plots');
                }

            });

            // TODO: batch events
            // TODO: add timezone to calendar
            // TODO: clear calendar then reload event
            //TODO: make sure that calendar exists before you check its events
            //TODO: set calendar timezone

        }

        //===================================
        //===== UTILITY FUNCTIONS ===========
        //===================================
        function appendPre(message) {
            var pre = document.getElementById('output');
            pre.innerHTML += message;
        }

        /*
         * delete events one by one but batch the requests
         */
        function deleteAllEvents(calendarId) {

            return new Promise(function (resolve) {
                var request = gapi.client.calendar.events.list({
                    'calendarId': calendarId,
                    'showDeleted': false,
                    'singleEvents': true,
                    'orderBy': 'startTime'
                });

                request.execute(function (resp) {
                    var events = resp.result.items;
                    if (events.length > 0) {
                        var batchDelete = gapi.client.newBatch();
                        for (var i = 0; i < events.length; i++) {
                            var event = events[i];
                            var request = deleteRequest(event.id);
                            batchDelete.add(request);
                        }
                        batchDelete.execute(function (resp) {
                            var msg = "No of events deleted before loading new ones: " + events.length +
                                    "\nresp:" + resp;
                            resolve(msg);
                        });
                    }
                    else {
                        var msg = "Nothing to delete in calendar events"
                        resolve(msg);
                    }
                });
            });
        }

        function createResource(startTime, endTime, summary, location) {
            return {
                "summary": summary || 'no summary',
                "location": location || 'empty location',
                "start": {
                    "dateTime": startTime //e.g. "2015-12-23T10:00:00.000-07:00"
                },
                "end": {
                    "dateTime": endTime //e.g. "2015-12-23T17:25:00.000-07:00"
                }
            };
        }

        function deleteRequest(eventId) {
            return gapi.client.calendar.events.delete({
                'calendarId': localStorage.createdCalendarId,
                'eventId': eventId
            });
        }

        function extractDate(date) {
            if (!(date instanceof Date))
                date = new Date(date);

            return ("0" + (date.getMonth() + 1)).slice(-2) + "-" + ("0" + date.getDate()).slice(-2) + "-" +
                    date.getFullYear();
        }

        function extractTime(date) {
            if (!(date instanceof Date))
                date = new Date(date);
            return roundToTwoDP(date.getHours() + date.getMinutes() / 60.0);
        }

        function getAllDwellTime(dayData) {

            if (dayData.length < 1)
                return [];

            var allResourcesForDay = [],
                    resource,
                    firstItem,
                    lastItem,
                    timeDiff,
                    currentLocObject,
                    locLabel,
                    latlng,
                    prevLocObject,
                    tmpStore = [];

            tmpStore.push(dayData[0]);
            for (var i = 1; i < dayData.length; i++) {
                currentLocObject = dayData[i];
                prevLocObject = dayData[i - 1];
                if (currentLocObject.locationLabel === prevLocObject.locationLabel && i !== dayData.length - 1) {
                    tmpStore.push(currentLocObject);
                }
                else {
                    firstItem = tmpStore[0];
                    lastItem = tmpStore[tmpStore.length - 1];
                    timeDiff = roundToTwoDP((lastItem.timestampMs - firstItem.timestampMs) / (1000 * 60 * 60));
                    locLabel = "Time Spent at " + firstItem.locationLabel + "( ~ " + timeDiff + " hours)";
                    latlng = {lat: firstItem.latitudeE7, lng: firstItem.longitudeE7}; //TODO: change input passed
                    resource = createResource(
                            new Date(firstItem.timestampMs),
                            new Date(lastItem.timestampMs),
                            locLabel, latlng);
                    allResourcesForDay.push(resource);

                    // reset tmpStore to store next location
                    tmpStore = [];
                }
            }

            return allResourcesForDay;
        }

        function getReversedGeodata(latlng) {

            return new Promise(function (resolve, reject) {

                var geocoder = new google.maps.Geocoder();
                var reversedAddress = 'no result address assigned';

                geocoder.geocode({'location': latlng}, function (results, status) {
                            if (status === google.maps.GeocoderStatus.OK) {
                                if (results[0]) {
                                    reversedAddress = results[0].formatted_address;
                                    resolve(reversedAddress);
                                } else {
                                    reversedAddress = "No results found for address.";
                                    reject(reversedAddress);
                                }
                            } else if (status == google.maps.GeocoderStatus.OVER_QUERY_LIMIT) {
                                reversedAddress = "Sadly OVER_QUERY_LIMIT error happened:";
                                reject(reversedAddress);
                            } else {
                                reversedAddress = "Geocoder failed due to: " + status;
                                reject(reversedAddress);
                            }
                        }
                );
            });
        }

        function getEventsFromDay(dayData) {
            var allEvents = [];
            var noOfEvents = 5;
            var summary;
            if (_.size(dayData) > 0) {

                for (var i = 0; i < noOfEvents; i++) {
                    summary = "(" + i + ") demoName";
                    var event = {
                        "summary": summary,
                        "location": "Somewhere in Noyes",
                        "start": {
                            "dateTime": "2015-12-23T10:00:00.000-07:00"
                        },
                        "end": {
                            "dateTime": "2015-12-23T17:25:00.000-07:00"
                        }
                    }
                    allEvents.push(event);
                }

            }
            return allEvents;
        }

        function insertRequest(event, calendarId) {
            return gapi.client.calendar.events.insert({
                'calendarId': calendarId,
                'resource': event
            });
        }

        function roundToTwoDP(num) {
            return +(Math.round(num + "e+2") + "e-2");
        }


    </script>

    <script src="https://apis.google.com/js/client.js?onload=checkAuth"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="http://maps.google.com/maps/api/js"></script>
    <script src="lib/underscore.js"></script>

</head>
<body>
<div id="authorize-div" style="display: none">
    <span>Authorize access to Google Calendar API</span>
    <!--Button for the user to click to initiate auth sequence -->
    <button id="authorize-button" onclick="handleAuthClick(event)">
        Authorize
    </button>
</div>
<pre id="output"></pre>
</body>
</html>